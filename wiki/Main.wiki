#summary Wiki Main Page
#labels Featured,Phase-Requirements,Phase-Deploy

= Introduction =
Discussion about this project: http://9xforums.com/forum/viewtopic.php?f=49&t=2629

=== Arduino Variometer / Altimeter over FR-Sky telemetry for open9x ===
http://openxvario.googlecode.com/svn/wiki/images/openxvarioAndD8R.jpg
http://openxvario.googlecode.com/svn/wiki/images/openxvarioNaked.jpg

watch out: in the picture the rs232 cable is connected to pin 10, in the current version i changed this to pin 9


I started this project in order to use the MS5611 barometric sensor to send data via FR-Sky to open9x.

=== Sensor data send to open9x ===
here´s an example how it might look in open9x:
http://imageshack.us/photo/my-images/593/20130202152825.jpg
ALT => the relative altitude
VSpd => the vertical speed
Dist => 279.22 the absolute height as calculated form air pressure+temp
Cels => the input voltage of the Arduino
RPM => 1056 mbar = the current air pressure (not the best resolution in this field...)
T1 => 25C the temperature measured byt the ms5611

the dist and RPM fields are being "misused" a bit here :D

you can configure this to your liking by just uncommenting some lines in the code.
e.g. you can choose what you want in the dist or RPM field: nothing, Altitude,Air pressure..

the following can be transmitted:
  * absolute altitude ( ID 0x10 and 0x21)
  * supply voltage as cell 0 in id 0x06
  * temperature (from MS5611) as T1 ID 0x02
  * 6 single voltage values connected to the pins as configured as cell 1-6 in id 0x06

WARNING: Do NOT attempt to directly connect these to your balance connector! This would only work for the first cell (from gnd) cell 2 and + would exceed the Arduino pin limits (keep the smoke in!)

It is all work in progress. It would be fairly easy to add in additional sensors if we stuff in the needed code. you could even try to get a 11DOF module working if you fancy all the data.

== Credits ==
I got the idea and a lot of code for this project from this thread: http://www.rcgroups.com/forums/showthread.php?t=1749208
The code to write the frsky packages is based on the work in this thread: http://fpv-community.de/showthread.php?18566-FrSky-Telemetrie-Protokoll
the voltage calibration code ist from here: http://provideyourown.com/2012/secret-arduino-voltmeter-measure-battery-voltage/
and thanks to bertrand for the changes to open 9x!

I of course do not take any warranty whatsoever for the instructions below. Do it at your own risk. Read and understand all of the information below before you begin.

== Stuff you will need ==

  * an open 9x based transmitter with audio and frsky telemetry modifications
  * an Arduino nano (builtin USB port +3.3v voltage in case you have a 3.3v Version of the sensor)
  * or an Arduino Pro Mini (more compact)
  * a MS5611 Sensor Module (preferable a 5V version) for around 15€-20€ on eBay
  * a suitable Fr-Sky telemetry enabled receiver with at least one analog signal ( A1 or A2) to transfer the lift/sink rate. If you want to receive the altimeter and supply voltage information as well you need a receiver with the RS232 interface like for example the D8R-II (any version should work)
  * a standard servo cable
  * a 2pin 2.54mm header
  * some heat shrink tube ( is used a 28mm one) or something else to keep the smoke inside
  * some knowledge of Arduino,some cable+coffee[/list]

== Connecting the Arduino to the receiver ==
WARNING: make sure you are using only one Power Source for the Arduino. If i connect the arduino to the PC, i always disconnect the 5V to the receiver and power the receiver via it´s own battery+BEC.

You can use a standard servo cable to connected the Arduino to a free servo port of the frsky receiver.
-GND and +5V from the servo port. go to the supply voltage pins on the Arduino.
The Arduino has to ways to feed it with power: 

  * the RAW or VIN  Pin takes  5 - 12 V use this one if you are conecting directly to a battery above 5v
  * the VCC pin takes regulated 5V use this one if you have a BEC

The serial output on pin 9 of the Arduino has to be connected to the RS232 RX pin on the FR-Sky receiver. You can use the signal line from the servo cable used to power the Arduino

http://openxvario.googlecode.com/svn/wiki/images/step1.jpg
http://openxvario.googlecode.com/svn/wiki/images/step2.jpg
http://openxvario.googlecode.com/svn/wiki/images/step3.jpg
http://openxvario.googlecode.com/svn/wiki/images/step4.jpg


== Connecting the MS5611 to the Arduino ==
The ms5611 has to be connected to the Arduino with the following connections:
The MS5611 module in the following picture is not the most common module, but works fine. It even has 2 seperated I2C bus connectors for the 2 differen voltages (3.3V/5V). I got this one from a seller located in UK over ebay.

https://openxvario.googlecode.com/svn/wiki/images/step5.jpg

  * SCLK to the A5 pin on the Arduino
  * SDA_I to the A4 pin on the Arduino
  * GND to GND on the Arduino
  * VDD to +5V on the Arduino (VCC)
on an arduino pro mini the A4+A5 pins are normally located on the inner part of the board (as in the picture). 

The more common modules can be mounted using a dual 2.54mm header pin. additionally you would then just need 2 small cables to connect the power.

=== Optional: connect analog climb rate signal to A1 or A2 ===
In case you receiver only has A1/ or A2 for telemetry you can still try to use the analog output mode for the climb rate: AnalogClimbRate

== Programming the Arduino ==
The code to put on your Arduino can be customized in various way. Check the CompileOptions page for details

here is the Arduino sketch you have to put on the Arduino: https://openxvario.googlecode.com/svn/branches/openxvario/openxvario.ino

SparkFUn has a nice tutorial in which they describe the programming of the Arduino pro mini: http://www.sparkfun.com/tutorials/244 just use the .INO file you can download on this page.
As a programmer i recommend the "FTDI basic" type of programmers which is available on ebay. I got one that has male headers directly on the programmer, so you can place the arduino directly on those headers. 
http://openxvario.googlecode.com/svn/wiki/images/programming.jpg

If your´s hasn´t got those male headers, just plug some header pins into the female headers of the porogrammer and the other end directly into the arduino pro mini.


== Setting up the sensor data in open9x ==
On the telemetry setup page, change the following values:

  * Usr Data: Proto to HUB
If you use the analog !ClimbRate option, use A1 or A2 and setup the chosen pin to the correct range ( 6m/s  + offset somewhere around -3m/s, adjust it to keep the climbrate around 0 with the vario on the desk)

  * Vario: Source to VARIO 
  * Limit *lower_range_limit,sink_tone_start,rise_tone_start,upper_tone_limit*

==> The lower and upper limit will be used to define the range for the tone generation 
The range is -10..-3 for the lower and +3..+10 for the upper limit in 1m/s steps . Theses 2 values define the possible range of vertical speeds that will be mapped to different audio results. if you want to have a sensitive audible feedback, you might want to set these to outer limit e.g. to -3 and +3. this will result in all the possible audio pitch and beep speeds to be used for vertical speeds of -3 to +3 m/s

==> The inner limits
The range her is -2..0 and 0..+2m/s in 0.1m/s steps
The inner values will be used to define a silent area for the vario tone. you can set these for example to -1 to +0.20 . This will tell the vario to be quiet in all vertical speeds between sinking -1m/s to lift of 0.20m/s .

Play around with these to receive the best tone

  * configure your telemetry screens to your liking..
  * setup a switch to turn on/off the vario tone generation
the remaining setup fot the switch + telemetry screen is described in the open9x documentation
== Some comments about the code ==
The pressure values from the sensor will be placed in a rotating buffer. Increasing the size of this buffer will reduce noise but also reduce reaction time.
All pin assignment are configurable.
If you are using “#define DEBUG”, this interferes with the data read from the MS5611 and the generation of the PWM signal, resulting in unexpected output.


Have fun,

rainer