#summary Wiki Main Page
#labels Featured,Phase-Requirements,Phase-Deploy

= Introduction =
If you found this page, you are probably as well infected by the "build your own Variometer" virus. 
The openXvario is my contribution to the 9X community. 
It is designed to work together with the open source firmware open9x for the turnigy 9x transmitter. but with little modifications it should work with any FrSky telemetry enabled system.

Discussion about this project: http://9xforums.com/forum/viewforum.php?f=86
https://openxvario.googlecode.com/svn/wiki/images/Prototype2Back.jpg



=== Arduino Variometer / Altimeter over FR-Sky telemetry for open9x ===
https://openxvario.googlecode.com/svn/wiki/images/Prototype2.jpg
Hint: this prototype is not using the ppm signal from the receiver. new pictures will follow..
https://openxvario.googlecode.com/svn/wiki/images/Prototype2Back.jpg

=== Sensor data send to open9x ===
here´s an example how it might look in open9x:
https://openxvario.googlecode.com/svn/wiki/images/open9xTelemetryScreen.jpg
ALT => the relative altitude
VSpd => the vertical speed
Dist => 279.22 the absolute height as calculated form air pressure+temp
Cels => the input voltage of the Arduino
RPM => 1056 mbar = the current air pressure (not the best resolution in this field...)
T1 => 25C the temperature measured byt the ms5611

the dist and RPM fields are being "misused" a bit here :D

You can configure this to your liking by just uncommenting some lines in the code. e.g. you can choose what you want in the dist or RPM field: nothing, Altitude,Air pressure..

the following can be transmitted:
  * absolute altitude (ID 0x10 and 0x21)
  * supply voltage as VFAS Voltage ( id 0x39) or as cell 0 in id 0x06
  * temperature (from MS5611) as T1 ID 0x02
  * 6 single voltage values connected to the pins as configured as cell 1-6 in id 0x06
  * various other field for diagnostic purposed ( e.g. internal kalman filter parameters

WARNING: Do NOT attempt to directly connect the 6 available cell voltages to your balance connector! This would only work for the first cell (from gnd) cell 2 and + would exceed the Arduino pin limits (keep the smoke in!)

It is all work in progress. It would be fairly easy to add in additional sensors if we stuff in the needed code. 

== Credits ==
I got the idea and a lot of code for this project from this thread: http://www.rcgroups.com/forums/showthread.php?t=1749208

The code to write the frsky packages is based on the work in this thread: http://fpv-community.de/showthread.php?18566-FrSky-Telemetrie-Protokoll

The voltage calibration code ist from here: http://provideyourown.com/2012/secret-arduino-voltmeter-measure-battery-voltage/

The kalman filter is based on the information from this site: http://interactive-matter.eu/blog/2009/12/18/filtering-sensor-data-with-a-kalman-filter/

and many thanks to bertrand for the changes to open 9x!


I of course do not take any warranty whatsoever for the instructions below. Do it at your own risk. Read and understand all of the information below before you begin.

== Stuff you will need ==
  * an open 9x based transmitter with audio and frsky telemetry modifications
  * or an Arduino Pro Mini 5V 16Mhz 
  * a 5V MS5611 Sensor Module for around 15€-20€ on eBay
  * a suitable Fr-Sky telemetry enabled receiver with a RS232 port or alternativly one free analog input signal (A1 or A2) to transfer the lift/sink rate. 
  * a standard servo cable
  * one single lead and connector pin from a servo connector (or a female header pin and a piece of cable.
  * a 2pin 2.54mm header ( to easiliy mount the more common MS5611 modules
  * some heat shrink tube for the variometer(I used a 28mm one) 
  * some smaller heat shrink tube for the female header pins used to connect the openXvario to the receiver's RS232 / A1/2 port


== Connecting the Arduino to the receiver ==
WARNING: make sure you are using only one Power Source for the Arduino. If you connect the arduino to the PC, always disconnect the 5V to the receiver first! 

You can use a standard servo cable to connected the Arduino to a free servo port of the frsky receiver.
Pins to be connected:
{{{
    Powering the Arduino:
     Arduino GND   --------------------- Receiver GND (Servo Plug)
     Arduino RAW   --------------------- Receiver +5V (Servo Plug)
    Optional PPM Input from servo port to the arduino:
    Arduino Pin 4 --------------------- Receiver PPM Signal (Servo Plug)

    Output of the data to the receiver:
     Arduino Pin 2 --------------------- Receiver RX Pin (If there is a RS232 Port on the receiver)
    or
     Arduino Pin 3 --------------------- Receiver A1 or A2 (If there is NO RS232 Port on the receiver)

    connecting the MS56711 module to the receiver
     Arduino Pin A4--------------------- MS5611 SDA
     Arduino Pin A5--------------------- MS5611 SCL
     Arduino VCC   --------------------- MS5611 5V
     Arduino GND   --------------------- MS5611 GND

}}}

https://openxvario.googlecode.com/svn/wiki/images/Wiring%20Diagram%20V2.png

The MS5611 module in the above picture is not the most common module, but works fine. It even has 2 seperated I2C bus connectors for the 2 differen voltages (3.3V/5V). I got this one from a seller located in UK over ebay.
On an arduino pro mini the A4+A5 pins are normally located on the inner part of the board (as in the picture). 

The more common modules can be mounted using a dual 2.54mm header pin. additionally you would then just need 2 small cables to connect the power.

=== Optional: connect analog climb rate signal to A1 or A2 ===
In case you receiver only has A1/ or A2 for telemetry you can still try to use the analog output mode for the climb rate: AnalogClimbRate

== Programming the Arduino ==
The code to put on your Arduino can be customized in various way. Check the CompileOptions page for details

here is the Arduino sketch you have to put on the Arduino: https://openxvario.googlecode.com/svn/branches/openxvario/openxvario.ino

SparkFUn has a nice tutorial in which they describe the programming of the Arduino pro mini: http://www.sparkfun.com/tutorials/244 just use the .INO file you can download on this page.
As a programmer i recommend the "FTDI basic" type of programmers which is available on ebay. I got one that has male headers directly on the programmer, so you can place the arduino directly on those headers. 
http://openxvario.googlecode.com/svn/wiki/images/programming.jpg

If your´s hasn´t got those male headers, just plug some header pins into the female headers of the porogrammer and the other end directly into the arduino pro mini.


== Setting up the sensor data in open9x ==
On the telemetry setup page, change the following values:

  * Usr Data: Proto to HUB
If you use the analog !ClimbRate option, use A1 or A2 and setup the chosen pin to the correct range ( 6m/s  + offset somewhere around -3m/s, adjust it to keep the climbrate around 0 with the vario on the desk)

  * Vario: Source to VARIO 
  * Limit *lower_range_limit,sink_tone_start,rise_tone_start,upper_tone_limit*

==> The lower and upper limit will be used to define the range for the tone generation 
The range is -10..-3 for the lower and +3..+10 for the upper limit in 1m/s steps . Theses 2 values define the possible range of vertical speeds that will be mapped to different audio results. if you want to have a sensitive audible feedback, you might want to set these to outer limit e.g. to -3 and +3. this will result in all the possible audio pitch and beep speeds to be used for vertical speeds of -3 to +3 m/s

==> The inner limits
The range her is -2..0 and 0..+2m/s in 0.1m/s steps
The inner values will be used to define a silent area for the vario tone. you can set these for example to -1 to +0.20 . This will tell the vario to be quiet in all vertical speeds between sinking -1m/s to lift of 0.20m/s .

Play around with these to receive the best tone

  * configure your telemetry screens to your liking..
  * setup a switch to turn on/off the vario tone generation
the remaining setup fot the switch + telemetry screen is described in the open9x documentation
== Some comments about the code ==
The pressure values from the sensor will be placed in a rotating buffer. Increasing the size of this buffer will reduce noise but also reduce reaction time.
All pin assignment are configurable.
If you are using “#define DEBUG”, this interferes with the data read from the MS5611 and the generation of the PWM signal, resulting in unexpected output.


Have fun,

rainer